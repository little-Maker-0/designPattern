工厂模式包含了工厂方法模式和抽象工厂模式。

所有的工厂模式都用来封装对象的创建。

工厂方法模式定义了一个创建对象的接口（抽象方法），但由子类决定要实例化的对象是哪一个，工厂方法让类把实例化延迟到子类

案例引入：我们有一个披萨店类，它的主要职责就是根据用户传入的披萨类型来定制披萨，也就是说，硬编码创建对象到方法中。我们识别变化的部分，将创建对象的代码封装到一个抽象方法中，由子类决定。

设计原则：对拓展开放，对修改关闭。封装变化。依赖倒置原则（要依赖抽象，不要依赖具体类）

补：一开始我们直接实例化pizza对象，这让披萨店类很依赖各个披萨类，披萨一变，披萨店就要变。我们说这是高层组件依赖于底层组件。为此，引入工厂方法。这样子，披萨店就依赖于披萨抽象了。

抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

案例引入：我们希望保证披萨原料的质量，也就是说利用工厂来创建披萨的原料家族。我们定义一个抽象工厂接口，里面定义了所有创建原料的方法。当创建一个披萨类时，传入相关的原料工厂接口参数。披萨类创建原料时，不需要知道怎么实现这些原料，创建的工作交给工厂处理。这样我们的代码就从实际的工厂解耦，以便在不同上下文里创建各种各样的工厂，制造各种各样的产品。


