例子引出：咖啡店订单系统设计

原本的设计：有一个抽象基类beverage实现了describtion属性和get方法，cost方法交由子类实现，有各种小料实例变量，其他所有的子类都实现于此类。这是个不好的设计，违反了对拓展开放，对修改关闭的原则。当小料涨价、出现新的小料、双倍小料时，我们不得不修改基类。

正确的设计：加入装饰者抽象类，他继承了饮料基类。这样装饰者与被装饰者拥有同样地基类，也就是说定义了相同地“行为”。
比如说我想要摩卡，那就创建一个摩卡对象，若还想要奶泡，就创建一个奶泡装饰者，并包装摩卡对象，依此类推当计算价钱时，
先调用最外层的包装器cost方法，该方法又调用内层包装器的cost方法，直到调用被包装的对象。
装饰者模式动态地将责任附加到对象上，若要拓展功能，装饰者提高了比继承更有弹性地方案。

JDK中的应用：Java I/O。InputStream是我们的抽象组件，即被装饰者，其子类实现了各种基本读取功能，FilterinputStream是我们的抽象装饰者，其子类是用来包装InputStream的。我们也可以实现自己的包装器，只需要继承FilterInputStream。

web中的应用：当我们使用过滤器来压缩响应时，可以在过滤链的dofilter方法中传入一个定制的响应对象，该对象的类型是一个装饰器类，继承了httpservletresponsewrapper，装饰了httpservletresponse。